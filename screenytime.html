<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Screenytime</title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fff;
      color: #1a1a1a;
      line-height: 1.5;
      padding: 40px 24px 80px;
      max-width: 720px;
      margin: 0 auto;
    }

    h1 {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .subtitle {
      color: #666;
      font-size: 14px;
      margin-bottom: 32px;
    }

    .browser-warning {
      background: #FFF9E6;
      border: 1px solid #F2C94C;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 13px;
      margin-bottom: 24px;
      display: none;
    }

    /* Drop zone */
    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 12px;
      padding: 48px 24px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: #1ABC9C;
      background: #f0fdfb;
    }

    .drop-zone-label {
      font-size: 16px;
      font-weight: 500;
      color: #333;
    }

    .drop-zone-hint {
      font-size: 13px;
      color: #999;
      margin-top: 8px;
    }

    .file-info {
      display: none;
      margin-top: 16px;
      font-size: 14px;
      color: #333;
    }

    .file-info .filename {
      font-weight: 600;
    }

    .file-info .filesize {
      color: #666;
      margin-left: 8px;
    }

    .file-warning {
      color: #b45309;
      font-size: 13px;
      margin-top: 8px;
      display: none;
    }

    .preview-video, .preview-image {
      display: none;
      margin-top: 16px;
      width: 100%;
      max-width: 320px;
      border-radius: 8px;
      background: #000;
    }

    /* Settings */
    .settings {
      display: none;
      margin-top: 32px;
    }

    .settings-section {
      margin-bottom: 28px;
    }

    .settings-section label,
    .section-label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    /* Color picker */
    .color-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .color-swatch {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: 2px solid #ddd;
      flex-shrink: 0;
    }

    .color-input {
      width: 100px;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
    }

    .color-input:focus {
      outline: none;
      border-color: #1ABC9C;
    }

    .color-presets {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .color-preset {
      padding: 6px 14px;
      border-radius: 20px;
      border: 2px solid #1a1a1a;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .color-preset:hover {
      transform: scale(1.05);
    }

    .color-preset:active {
      transform: scale(0.97);
    }

    /* Speed control */
    .speed-options {
      display: flex;
      gap: 0;
      border: 2px solid #1a1a1a;
      border-radius: 8px;
      overflow: hidden;
      width: fit-content;
    }

    .speed-option {
      padding: 8px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      background: #fff;
      border-right: 2px solid #1a1a1a;
      transition: background 0.1s, color 0.1s;
    }

    .speed-option:last-child {
      border-right: none;
    }

    .speed-option.active {
      background: #1a1a1a;
      color: #fff;
    }

    .speed-option:hover:not(.active) {
      background: #f5f5f5;
    }

    /* End card */
    .endcard-drop {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      font-size: 14px;
      color: #666;
      transition: border-color 0.15s, background 0.15s;
    }

    .endcard-drop:hover,
    .endcard-drop.dragover {
      border-color: #1ABC9C;
      background: #f0fdfb;
    }

    .endcard-info {
      display: none;
      font-size: 14px;
      margin-top: 8px;
    }

    .endcard-info .filename {
      font-weight: 600;
    }

    .remove-btn {
      background: none;
      border: none;
      color: #e74c3c;
      font-size: 13px;
      cursor: pointer;
      margin-left: 12px;
      text-decoration: underline;
    }

    .endcard-note {
      font-size: 12px;
      color: #999;
      margin-top: 8px;
    }

    /* Process section */
    .process-section {
      display: none;
      margin-top: 32px;
    }

    .process-btn {
      width: 100%;
      padding: 14px 24px;
      font-size: 16px;
      font-weight: 700;
      border: 2px solid #1a1a1a;
      border-radius: 10px;
      cursor: pointer;
      background: #1ABC9C;
      color: #fff;
      transition: transform 0.1s, box-shadow 0.1s;
      box-shadow: 3px 3px 0 #1a1a1a;
    }

    .process-btn:hover:not(:disabled) {
      transform: translate(-1px, -1px);
      box-shadow: 4px 4px 0 #1a1a1a;
    }

    .process-btn:active:not(:disabled) {
      transform: translate(2px, 2px);
      box-shadow: 1px 1px 0 #1a1a1a;
    }

    .process-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .process-btn.downloading {
      background: #1a1a1a;
    }

    .progress-container {
      display: none;
      margin-top: 16px;
    }

    .progress-bar-track {
      width: 100%;
      height: 8px;
      background: #eee;
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: #1ABC9C;
      border-radius: 4px;
      width: 0%;
      transition: width 0.2s;
    }

    .progress-text {
      font-size: 13px;
      color: #666;
      margin-top: 6px;
      text-align: center;
    }

    .reset-link {
      display: none;
      text-align: center;
      margin-top: 16px;
    }

    .reset-link a {
      color: #1ABC9C;
      font-size: 14px;
      cursor: pointer;
      text-decoration: underline;
    }

    .error-message {
      display: none;
      background: #fef2f2;
      border: 1px solid #fca5a5;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 13px;
      color: #b91c1c;
      margin-top: 16px;
    }

    hr {
      border: none;
      border-top: 1px solid #eee;
      margin: 32px 0;
    }
  </style>
</head>
<body>

  <h1>Screenytime</h1>
  <p class="subtitle">Wrap screen recordings in a device frame. All processing happens in your browser.</p>

  <div class="browser-warning" id="browserWarning"></div>

  <!-- Section 1: Upload -->
  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-label">Drag & drop screen recording or image<br>or click to browse</div>
    <div class="drop-zone-hint">Accepts MP4, MOV, PNG, JPG</div>
  </div>
  <input type="file" id="fileInput" accept="video/mp4,video/quicktime,.mp4,.mov,image/png,image/jpeg,.png,.jpg,.jpeg" hidden>

  <div class="file-info" id="fileInfo">
    <span class="filename" id="fileName"></span>
    <span class="filesize" id="fileSize"></span>
  </div>
  <div class="file-warning" id="fileWarning">This file is very large and may take a while to process.</div>
  <video class="preview-video" id="previewVideo" muted controls playsinline></video>
  <img class="preview-image" id="previewImage">

  <!-- Section 2: Settings -->
  <div class="settings" id="settings">
    <hr>

    <div class="settings-section">
      <span class="section-label">Device</span>
      <div class="speed-options" id="deviceOptions">
        <button class="speed-option active" data-device="apple">Apple</button>
        <button class="speed-option" data-device="android">Android</button>
      </div>
    </div>

    <div class="settings-section">
      <span class="section-label">Frame Color</span>
      <div class="color-presets" id="frameColorOptions"></div>
    </div>

    <div class="settings-section">
      <label>Background Color</label>
      <div class="color-row">
        <div class="color-swatch" id="colorSwatch"></div>
        <input type="text" class="color-input" id="colorInput" value="#F5F2EB" maxlength="7" spellcheck="false">
      </div>
      <div class="color-presets" id="colorPresets"></div>
    </div>

    <div id="videoOnlySettings">
      <div class="settings-section">
        <span class="section-label">Speed</span>
        <div class="speed-options" id="speedOptions">
          <button class="speed-option active" data-speed="1">1x</button>
          <button class="speed-option" data-speed="1.5">1.5x</button>
          <button class="speed-option" data-speed="2">2x</button>
        </div>
      </div>

      <div class="settings-section">
        <span class="section-label">Intro Card (Optional)</span>
        <div class="endcard-drop" id="introcardDrop">Add intro card video (MP4)</div>
        <input type="file" id="introcardInput" accept="video/mp4,.mp4" hidden>
        <div class="endcard-info" id="introcardInfo">
          <span class="filename" id="introcardName"></span>
          <button class="remove-btn" id="removeIntrocard">Remove</button>
        </div>
        <div class="endcard-note">Intro card will play before the screen recording</div>
      </div>

      <div class="settings-section">
        <span class="section-label">End Card (Optional)</span>
        <div class="endcard-drop" id="endcardDrop">Add end card video (MP4)</div>
        <input type="file" id="endcardInput" accept="video/mp4,.mp4" hidden>
        <div class="endcard-info" id="endcardInfo">
          <span class="filename" id="endcardName"></span>
          <button class="remove-btn" id="removeEndcard">Remove</button>
        </div>
        <div class="endcard-note">End card will play after the screen recording</div>
      </div>
    </div>
  </div>

  <!-- Section 3: Process -->
  <div class="process-section" id="processSection">
    <button class="process-btn" id="processBtn" disabled>Create Video</button>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar-track">
        <div class="progress-bar-fill" id="progressFill"></div>
      </div>
      <div class="progress-text" id="progressText">Processing...</div>
    </div>

    <div class="error-message" id="errorMessage"></div>

    <div class="reset-link" id="resetLink">
      <a id="resetBtn">Create Another</a>
    </div>
  </div>

<script>
(function() {
  'use strict';

  // --- Device Profiles ---
  // Each type defines shared dimensions/layout. Variants are different frame colors.
  // renderScale upscales small frames so the internal canvas is always >= 1080×1920.
  var DEVICE_TYPES = {
    apple: {
      frameW: 1310, frameH: 2710,
      screenWPct: 93, screenHPct: 98,
      cornerRadius: 175, padding: 80,
      renderScale: 1,
      variants: [
        { name: 'Natural', img: 'device-frame-natural.png' },
        { name: 'White', img: 'device-frame-white.png' },
        { name: 'Black', img: 'device-frame-black.png' },
        { name: 'Desert', img: 'device-frame-desert.png' },
      ],
    },
    android: {
      frameW: 353, frameH: 745,
      screenWPct: 98, screenHPct: 98,
      cornerRadius: 53, padding: 15,
      renderScale: 4,
      variants: [
        { name: 'Obsidian', img: 'device-frame-android-obsidan.png' },
        { name: 'Porcelain', img: 'device-frame-android-porcelain.png' },
        { name: 'Pink Quartz', img: 'device-frame-android-pink-quartz.png' },
        { name: 'Hazel', img: 'device-frame-android-hazel.png' },
      ],
    },
  };

  // Compute all derived layout values from device type + variant index
  function getDeviceLayout(deviceType, variantIndex) {
    var d = DEVICE_TYPES[deviceType];
    var variant = d.variants[variantIndex || 0];
    var s = d.renderScale;

    var frameW = d.frameW * s;
    var frameH = d.frameH * s;
    var padding = d.padding * s;
    var cornerRadius = d.cornerRadius * s;

    var screenW = Math.floor(frameW * d.screenWPct / 100);
    var screenH = Math.floor(frameH * d.screenHPct / 100);
    screenW = Math.floor(screenW / 2) * 2;
    screenH = Math.floor(screenH / 2) * 2;

    var canvasW = Math.floor((frameW + padding * 2) / 2) * 2;
    var canvasH = Math.floor((frameH + padding * 2) / 2) * 2;

    var screenX = Math.floor((frameW - screenW) / 2) + padding;
    var screenY = Math.floor((frameH - screenH) / 2) + padding;
    var frameX = padding;
    var frameY = padding;

    return {
      frameImg: variant.img,
      frameW: frameW, frameH: frameH,
      screenW: screenW, screenH: screenH,
      canvasW: canvasW, canvasH: canvasH,
      screenX: screenX, screenY: screenY,
      frameX: frameX, frameY: frameY,
      cornerRadius: cornerRadius,
    };
  }

  // --- Output constants (Reels-ready) ---
  var OUTPUT_W = 1080;
  var OUTPUT_H = 1920;
  var OUTPUT_PHONE_SCALE = 0.88;

  // --- Color Presets ---
  var PRESETS = [
    { name: 'Cream',  hex: '#F5F2EB', dark: false },
    { name: 'Teal',   hex: '#1ABC9C', dark: true  },
    { name: 'Yellow', hex: '#F2C94C', dark: false },
    { name: 'Black',  hex: '#1A1A1A', dark: true  },
    { name: 'NBA',    hex: '#EF7328', dark: true  },
    { name: 'EPL',    hex: '#A17FFF', dark: true  },
    { name: 'NFL',    hex: '#3BA978', dark: true  },
    { name: 'MLB',    hex: '#7A93D2', dark: false },
  ];

  // --- DOM refs ---
  var dropZone = document.getElementById('dropZone');
  var fileInput = document.getElementById('fileInput');
  var fileInfo = document.getElementById('fileInfo');
  var fileName = document.getElementById('fileName');
  var fileSize = document.getElementById('fileSize');
  var fileWarning = document.getElementById('fileWarning');
  var previewVideo = document.getElementById('previewVideo');
  var previewImage = document.getElementById('previewImage');
  var videoOnlySettings = document.getElementById('videoOnlySettings');
  var settings = document.getElementById('settings');
  var colorSwatch = document.getElementById('colorSwatch');
  var colorInput = document.getElementById('colorInput');
  var colorPresets = document.getElementById('colorPresets');
  var deviceOptions = document.getElementById('deviceOptions');
  var frameColorOptions = document.getElementById('frameColorOptions');
  var speedOptions = document.getElementById('speedOptions');
  var introcardDrop = document.getElementById('introcardDrop');
  var introcardInput = document.getElementById('introcardInput');
  var introcardInfo = document.getElementById('introcardInfo');
  var introcardName = document.getElementById('introcardName');
  var removeIntrocard = document.getElementById('removeIntrocard');
  var endcardDrop = document.getElementById('endcardDrop');
  var endcardInput = document.getElementById('endcardInput');
  var endcardInfo = document.getElementById('endcardInfo');
  var endcardName = document.getElementById('endcardName');
  var removeEndcard = document.getElementById('removeEndcard');
  var processSection = document.getElementById('processSection');
  var processBtn = document.getElementById('processBtn');
  var progressContainer = document.getElementById('progressContainer');
  var progressFill = document.getElementById('progressFill');
  var progressText = document.getElementById('progressText');
  var errorMessage = document.getElementById('errorMessage');
  var resetLink = document.getElementById('resetLink');
  var resetBtn = document.getElementById('resetBtn');
  var browserWarning = document.getElementById('browserWarning');

  // --- State ---
  var videoFile = null;
  var imageFile = null;
  var inputMode = null; // 'video' or 'image'
  var introcardFile = null;
  var endcardFile = null;
  var bgColor = '#F5F2EB';
  var speed = 1;
  var device = 'apple';
  var frameVariant = 0;
  var processing = false;
  var resultBlob = null;

  // --- Browser check ---
  (function checkBrowser() {
    if (typeof MediaRecorder === 'undefined') {
      browserWarning.textContent = "Your browser doesn't support video recording. Try Chrome or Edge.";
      browserWarning.style.display = 'block';
      return;
    }
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (isSafari) {
      browserWarning.textContent = 'For best results, use Chrome or Edge. Safari has limited video recording support.';
      browserWarning.style.display = 'block';
    }
  })();

  // --- Color presets ---
  PRESETS.forEach(function(p) {
    var btn = document.createElement('button');
    btn.className = 'color-preset';
    btn.textContent = p.name;
    btn.style.background = p.hex;
    btn.style.color = p.dark ? '#fff' : '#1a1a1a';
    btn.addEventListener('click', function() {
      setColor(p.hex);
    });
    colorPresets.appendChild(btn);
  });

  function setColor(hex) {
    bgColor = hex;
    colorInput.value = hex;
    colorSwatch.style.background = hex;
    updateProcessBtn();
  }

  setColor('#F5F2EB');

  colorInput.addEventListener('input', function() {
    var v = colorInput.value.trim();
    if (v && v[0] !== '#') v = '#' + v;
    if (/^#[0-9A-Fa-f]{6}$/.test(v)) {
      setColor(v);
    }
  });

  // --- Device selector ---
  function buildFrameColorButtons(deviceType) {
    frameColorOptions.innerHTML = '';
    var variants = DEVICE_TYPES[deviceType].variants;
    variants.forEach(function(v, i) {
      var btn = document.createElement('button');
      btn.className = 'color-preset';
      btn.textContent = v.name;
      btn.style.background = i === 0 ? '#1a1a1a' : '#fff';
      btn.style.color = i === 0 ? '#fff' : '#1a1a1a';
      btn.addEventListener('click', function() {
        frameVariant = i;
        frameColorOptions.querySelectorAll('.color-preset').forEach(function(b, j) {
          b.style.background = j === i ? '#1a1a1a' : '#fff';
          b.style.color = j === i ? '#fff' : '#1a1a1a';
        });
      });
      frameColorOptions.appendChild(btn);
    });
  }

  buildFrameColorButtons('apple');

  deviceOptions.addEventListener('click', function(e) {
    var btn = e.target.closest('.speed-option');
    if (!btn || !btn.dataset.device) return;
    deviceOptions.querySelectorAll('.speed-option').forEach(function(b) { b.classList.remove('active'); });
    btn.classList.add('active');
    device = btn.dataset.device;
    frameVariant = 0;
    buildFrameColorButtons(device);
  });

  // --- Speed ---
  speedOptions.addEventListener('click', function(e) {
    var btn = e.target.closest('.speed-option');
    if (!btn || !btn.dataset.speed) return;
    speedOptions.querySelectorAll('.speed-option').forEach(function(b) { b.classList.remove('active'); });
    btn.classList.add('active');
    speed = parseFloat(btn.dataset.speed);
  });

  // --- File upload (video or image) ---
  dropZone.addEventListener('click', function() { fileInput.click(); });
  dropZone.addEventListener('dragover', function(e) { e.preventDefault(); dropZone.classList.add('dragover'); });
  dropZone.addEventListener('dragleave', function() { dropZone.classList.remove('dragover'); });
  dropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleUpload(e.dataTransfer.files[0]);
  });
  fileInput.addEventListener('change', function() {
    if (fileInput.files.length) handleUpload(fileInput.files[0]);
  });

  function isImageFile(file) {
    return file.type.match(/^image\/(png|jpeg|jpg)$/i) || file.name.match(/\.(png|jpe?g)$/i);
  }

  function isVideoFile(file) {
    var validTypes = ['video/mp4', 'video/quicktime'];
    return validTypes.includes(file.type) || file.name.match(/\.(mp4|mov)$/i);
  }

  function handleUpload(file) {
    if (isImageFile(file)) {
      handleImageFile(file);
    } else if (isVideoFile(file)) {
      handleVideoFile(file);
    } else {
      showError('Only MP4, MOV, PNG, and JPG files are supported.');
    }
  }

  function handleVideoFile(file) {
    hideError();
    videoFile = file;
    imageFile = null;
    inputMode = 'video';
    fileName.textContent = file.name;
    fileSize.textContent = '(' + formatSize(file.size) + ')';
    fileInfo.style.display = 'block';

    if (file.size > 200 * 1024 * 1024) {
      fileWarning.style.display = 'block';
    } else {
      fileWarning.style.display = 'none';
    }

    var url = URL.createObjectURL(file);
    previewVideo.src = url;
    previewVideo.style.display = 'block';
    previewImage.style.display = 'none';

    videoOnlySettings.style.display = 'block';
    processBtn.textContent = 'Create Video';
    settings.style.display = 'block';
    processSection.style.display = 'block';
    updateProcessBtn();
  }

  function handleImageFile(file) {
    hideError();
    imageFile = file;
    videoFile = null;
    inputMode = 'image';
    fileName.textContent = file.name;
    fileSize.textContent = '(' + formatSize(file.size) + ')';
    fileInfo.style.display = 'block';
    fileWarning.style.display = 'none';

    var url = URL.createObjectURL(file);
    previewImage.src = url;
    previewImage.style.display = 'block';
    previewVideo.style.display = 'none';

    videoOnlySettings.style.display = 'none';
    processBtn.textContent = 'Create Image';
    settings.style.display = 'block';
    processSection.style.display = 'block';
    updateProcessBtn();
  }

  // --- Intro card upload ---
  introcardDrop.addEventListener('click', function() { introcardInput.click(); });
  introcardDrop.addEventListener('dragover', function(e) { e.preventDefault(); introcardDrop.classList.add('dragover'); });
  introcardDrop.addEventListener('dragleave', function() { introcardDrop.classList.remove('dragover'); });
  introcardDrop.addEventListener('drop', function(e) {
    e.preventDefault();
    introcardDrop.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleIntrocard(e.dataTransfer.files[0]);
  });
  introcardInput.addEventListener('change', function() {
    if (introcardInput.files.length) handleIntrocard(introcardInput.files[0]);
  });

  function handleIntrocard(file) {
    if (!file.type.match(/video\/mp4/i) && !file.name.match(/\.mp4$/i)) {
      showError('Intro card must be an MP4 file.');
      return;
    }
    hideError();
    introcardFile = file;
    introcardName.textContent = file.name;
    introcardInfo.style.display = 'block';
    introcardDrop.style.display = 'none';
  }

  removeIntrocard.addEventListener('click', function() {
    introcardFile = null;
    introcardInfo.style.display = 'none';
    introcardDrop.style.display = 'block';
    introcardInput.value = '';
  });

  // --- End card upload ---
  endcardDrop.addEventListener('click', function() { endcardInput.click(); });
  endcardDrop.addEventListener('dragover', function(e) { e.preventDefault(); endcardDrop.classList.add('dragover'); });
  endcardDrop.addEventListener('dragleave', function() { endcardDrop.classList.remove('dragover'); });
  endcardDrop.addEventListener('drop', function(e) {
    e.preventDefault();
    endcardDrop.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleEndcard(e.dataTransfer.files[0]);
  });
  endcardInput.addEventListener('change', function() {
    if (endcardInput.files.length) handleEndcard(endcardInput.files[0]);
  });

  function handleEndcard(file) {
    if (!file.type.match(/video\/mp4/i) && !file.name.match(/\.mp4$/i)) {
      showError('End card must be an MP4 file.');
      return;
    }
    hideError();
    endcardFile = file;
    endcardName.textContent = file.name;
    endcardInfo.style.display = 'block';
    endcardDrop.style.display = 'none';
  }

  removeEndcard.addEventListener('click', function() {
    endcardFile = null;
    endcardInfo.style.display = 'none';
    endcardDrop.style.display = 'block';
    endcardInput.value = '';
  });

  // --- Process button state ---
  function updateProcessBtn() {
    var hasInput = videoFile || imageFile;
    var ready = hasInput && /^#[0-9A-Fa-f]{6}$/.test(bgColor);
    processBtn.disabled = !ready;
  }

  // --- Process / Download ---
  processBtn.addEventListener('click', async function() {
    if (resultBlob) {
      downloadResult();
      return;
    }
    if (processing) return;
    await startProcessing();
  });

  async function startProcessing() {
    processing = true;
    hideError();
    processBtn.textContent = 'Processing...';
    processBtn.disabled = true;
    resetLink.style.display = 'none';

    try {
      if (inputMode === 'image') {
        progressContainer.style.display = 'none';
        resultBlob = await processImage(imageFile, bgColor, device, frameVariant);
        processBtn.textContent = 'Download Image';
      } else {
        progressContainer.style.display = 'block';
        progressFill.style.width = '0%';
        progressText.textContent = 'Preparing...';
        resultBlob = await processVideo(videoFile, bgColor, speed, device, frameVariant, introcardFile, endcardFile);
        processBtn.textContent = 'Download Video';
      }
      processBtn.classList.add('downloading');
      processBtn.disabled = false;
      progressContainer.style.display = 'none';
      resetLink.style.display = 'block';
    } catch (err) {
      console.error(err);
      showError('Something went wrong during processing. Try a different file or refresh.');
      processBtn.textContent = inputMode === 'image' ? 'Create Image' : 'Create Video';
      processBtn.disabled = false;
      progressContainer.style.display = 'none';
    }
    processing = false;
  }

  function downloadResult() {
    if (!resultBlob) return;
    var ext = resultBlob.type.includes('png') ? 'png' : resultBlob.type.includes('mp4') ? 'mp4' : 'webm';
    var srcFile = videoFile || imageFile;
    var baseName = srcFile.name.replace(/\.[^.]+$/, '');
    var a = document.createElement('a');
    a.href = URL.createObjectURL(resultBlob);
    a.download = baseName + '-framed.' + ext;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function() { URL.revokeObjectURL(a.href); }, 1000);
  }

  // --- Reset ---
  resetBtn.addEventListener('click', function() {
    videoFile = null;
    imageFile = null;
    inputMode = null;
    introcardFile = null;
    endcardFile = null;
    resultBlob = null;
    processing = false;

    fileInput.value = '';
    introcardInput.value = '';
    endcardInput.value = '';
    fileInfo.style.display = 'none';
    fileWarning.style.display = 'none';
    previewVideo.style.display = 'none';
    previewVideo.src = '';
    previewImage.style.display = 'none';
    previewImage.src = '';
    videoOnlySettings.style.display = 'block';
    settings.style.display = 'none';
    processSection.style.display = 'none';
    progressContainer.style.display = 'none';
    resetLink.style.display = 'none';
    processBtn.textContent = 'Create Video';
    processBtn.classList.remove('downloading');
    processBtn.disabled = true;
    introcardInfo.style.display = 'none';
    introcardDrop.style.display = 'block';
    endcardInfo.style.display = 'none';
    endcardDrop.style.display = 'block';
    hideError();

    setColor('#F5F2EB');
    speed = 1;
    device = 'apple';
    frameVariant = 0;
    speedOptions.querySelectorAll('.speed-option').forEach(function(b) {
      b.classList.toggle('active', b.dataset.speed === '1');
    });
    deviceOptions.querySelectorAll('.speed-option').forEach(function(b) {
      b.classList.toggle('active', b.dataset.device === 'apple');
    });
    buildFrameColorButtons('apple');
  });

  // --- Helpers ---
  function formatSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }

  function showError(msg) {
    errorMessage.textContent = msg;
    errorMessage.style.display = 'block';
  }

  function hideError() {
    errorMessage.style.display = 'none';
  }

  function loadImage(src) {
    return new Promise(function(resolve, reject) {
      var img = new Image();
      img.onload = function() { resolve(img); };
      img.onerror = function() { reject(new Error('Failed to load image: ' + src)); };
      img.src = src;
    });
  }

  function waitForVideoReady(video) {
    return new Promise(function(resolve) {
      if (video.readyState >= 2) { resolve(); return; }
      video.onloadeddata = function() { resolve(); };
      video.load();
    });
  }

  // Play a video in real-time and call onFrame for each decoded frame.
  // Uses requestVideoFrameCallback (Chrome/Edge) for precise per-frame capture,
  // falls back to setInterval for other browsers.
  function playVideoAndCapture(video, playbackRate, onFrame) {
    video.playbackRate = playbackRate;

    return new Promise(function(resolve, reject) {
      var done = false;

      function finish() {
        if (done) return;
        done = true;
        // Capture the final frame
        onFrame(video);
        resolve();
      }

      video.addEventListener('ended', finish, { once: true });

      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
        function rvfcCallback() {
          if (done) return;
          onFrame(video);
          video.requestVideoFrameCallback(rvfcCallback);
        }
        video.requestVideoFrameCallback(rvfcCallback);
      } else {
        // Fallback: capture at ~30fps
        var iv = setInterval(function() {
          if (done || video.ended || video.paused) {
            clearInterval(iv);
            return;
          }
          onFrame(video);
        }, 33);
        video.addEventListener('ended', function() { clearInterval(iv); }, { once: true });
      }

      video.play().catch(function(err) {
        done = true;
        reject(err);
      });
    });
  }

  // Scale render canvas to output canvas, preserving aspect ratio and centering
  function scaleToOutput(outputCtx, renderCanvas, color) {
    var scale = Math.min(OUTPUT_W / renderCanvas.width, OUTPUT_H / renderCanvas.height) * OUTPUT_PHONE_SCALE;
    var dw = renderCanvas.width * scale;
    var dh = renderCanvas.height * scale;
    var dx = (OUTPUT_W - dw) / 2;
    var dy = (OUTPUT_H - dh) / 2;
    outputCtx.fillStyle = color;
    outputCtx.fillRect(0, 0, OUTPUT_W, OUTPUT_H);
    outputCtx.drawImage(renderCanvas, dx, dy, dw, dh);
  }

  function getMediaRecorderOptions() {
    var types = [
      'video/mp4;codecs=avc1',
      'video/mp4',
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm',
    ];
    for (var i = 0; i < types.length; i++) {
      if (MediaRecorder.isTypeSupported(types[i])) {
        return { mimeType: types[i], videoBitsPerSecond: 16000000 };
      }
    }
    return { videoBitsPerSecond: 16000000 };
  }

  // --- Render image frame (same compositing as video, but for a static Image element) ---
  function renderImageFrame(ctx, imgElement, deviceFrameImg, color, layout) {
    var canvas = ctx.canvas;
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    var x = layout.screenX, y = layout.screenY;
    var w = layout.screenW, h = layout.screenH;
    var r = layout.cornerRadius;

    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.clip();

    var imgAspect = imgElement.naturalWidth / imgElement.naturalHeight;
    var screenAspect = w / h;
    var drawW, drawH, drawX, drawY;

    // Object-fit contain: show full image, letterbox/pillarbox if needed
    if (imgAspect > screenAspect) {
      drawW = w; drawH = w / imgAspect;
      drawX = x; drawY = y + (h - drawH) / 2;
    } else {
      drawH = h; drawW = h * imgAspect;
      drawX = x + (w - drawW) / 2; drawY = y;
    }

    ctx.drawImage(imgElement, drawX, drawY, drawW, drawH);
    ctx.restore();

    ctx.drawImage(deviceFrameImg, layout.frameX, layout.frameY, layout.frameW, layout.frameH);
  }

  // --- Process image (single frame → PNG) ---
  async function processImage(imgFile, color, deviceKey, variantIdx) {
    var layout = getDeviceLayout(deviceKey, variantIdx);

    var renderCanvas = document.createElement('canvas');
    renderCanvas.width = layout.canvasW;
    renderCanvas.height = layout.canvasH;
    var renderCtx = renderCanvas.getContext('2d');

    var outputCanvas = document.createElement('canvas');
    outputCanvas.width = OUTPUT_W;
    outputCanvas.height = OUTPUT_H;
    var outputCtx = outputCanvas.getContext('2d');
    outputCtx.imageSmoothingEnabled = true;
    outputCtx.imageSmoothingQuality = 'high';

    var deviceFrame = await loadImage(layout.frameImg);

    var img = await loadImage(URL.createObjectURL(imgFile));

    renderImageFrame(renderCtx, img, deviceFrame, color, layout);
    scaleToOutput(outputCtx, renderCanvas, color);

    URL.revokeObjectURL(img.src);

    return new Promise(function(resolve) {
      outputCanvas.toBlob(function(blob) { resolve(blob); }, 'image/png');
    });
  }

  // --- Render frame (device-agnostic) ---
  function renderFrame(ctx, videoElement, deviceFrameImg, color, layout) {
    var canvas = ctx.canvas;

    // 1. Background
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 2. Video with rounded corners
    ctx.save();
    var x = layout.screenX, y = layout.screenY;
    var w = layout.screenW, h = layout.screenH;
    var r = layout.cornerRadius;

    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.clip();

    // Object-fit contain: show full video, letterbox/pillarbox if needed
    var videoAspect = videoElement.videoWidth / videoElement.videoHeight;
    var screenAspect = w / h;
    var drawW, drawH, drawX, drawY;

    if (videoAspect > screenAspect) {
      drawW = w;
      drawH = w / videoAspect;
      drawX = x;
      drawY = y + (h - drawH) / 2;
    } else {
      drawH = h;
      drawW = h * videoAspect;
      drawX = x + (w - drawW) / 2;
      drawY = y;
    }

    ctx.drawImage(videoElement, drawX, drawY, drawW, drawH);
    ctx.restore();

    // 3. Device frame
    ctx.drawImage(deviceFrameImg, layout.frameX, layout.frameY, layout.frameW, layout.frameH);
  }

  // --- Main processing (real-time playback approach) ---
  // Plays videos natively and captures each decoded frame via requestVideoFrameCallback.
  // This avoids frame-by-frame seeking which causes glitches from keyframe-only access.
  async function processVideo(vFile, color, spd, deviceKey, variantIdx, icFile, ecFile) {
    var layout = getDeviceLayout(deviceKey, variantIdx);

    // Internal canvas: full resolution for quality compositing
    var renderCanvas = document.createElement('canvas');
    renderCanvas.width = layout.canvasW;
    renderCanvas.height = layout.canvasH;
    var renderCtx = renderCanvas.getContext('2d');

    // Output canvas: 1080×1920 for MediaRecorder capture
    var outputCanvas = document.createElement('canvas');
    outputCanvas.width = OUTPUT_W;
    outputCanvas.height = OUTPUT_H;
    var outputCtx = outputCanvas.getContext('2d');
    outputCtx.imageSmoothingEnabled = true;
    outputCtx.imageSmoothingQuality = 'high';

    // Load assets
    var deviceFrame = await loadImage(layout.frameImg);

    // MediaRecorder captures from the scaled output canvas.
    // captureStream(0) = manual mode: frames captured only when we call requestFrame().
    var stream = outputCanvas.captureStream(0);
    var videoTrack = stream.getVideoTracks()[0];
    var opts = getMediaRecorderOptions();
    var mediaRecorder = new MediaRecorder(stream, opts);
    var chunks = [];
    mediaRecorder.ondataavailable = function(e) {
      if (e.data && e.data.size > 0) chunks.push(e.data);
    };

    mediaRecorder.start(100);

    // Emit a single frame to the MediaRecorder stream
    function emitFrame() {
      if (videoTrack.requestFrame) videoTrack.requestFrame();
    }

    // Helper: render a full-screen video (for intro/end cards) to output canvas
    function renderFullScreen(vid) {
      outputCtx.fillStyle = color;
      outputCtx.fillRect(0, 0, OUTPUT_W, OUTPUT_H);
      var aspect = vid.videoWidth / vid.videoHeight;
      var outAspect = OUTPUT_W / OUTPUT_H;
      var dw, dh, dx, dy;
      if (aspect > outAspect) {
        dw = OUTPUT_W; dh = OUTPUT_W / aspect;
        dx = 0; dy = (OUTPUT_H - dh) / 2;
      } else {
        dh = OUTPUT_H; dw = OUTPUT_H * aspect;
        dx = (OUTPUT_W - dw) / 2; dy = 0;
      }
      outputCtx.drawImage(vid, dx, dy, dw, dh);
      emitFrame();
    }

    // --- Intro card (if provided) ---
    if (icFile) {
      progressText.textContent = 'Rendering intro card...';
      var introVid = document.createElement('video');
      introVid.src = URL.createObjectURL(icFile);
      introVid.muted = true;
      introVid.playsInline = true;
      await waitForVideoReady(introVid);

      await playVideoAndCapture(introVid, 1, function(vid) {
        renderFullScreen(vid);
      });
      introVid.pause();
      URL.revokeObjectURL(introVid.src);
    }

    // --- Main video (with device frame, at selected speed) ---
    var video = document.createElement('video');
    video.src = URL.createObjectURL(vFile);
    video.muted = true;
    video.playsInline = true;
    await waitForVideoReady(video);

    var estimatedFrames = Math.ceil((video.duration / spd) * 30);
    var frameCount = 0;

    await playVideoAndCapture(video, spd, function(vid) {
      renderFrame(renderCtx, vid, deviceFrame, color, layout);
      scaleToOutput(outputCtx, renderCanvas, color);
      emitFrame();

      frameCount++;
      var pct = Math.min(100, Math.round((vid.currentTime / vid.duration) * 100));
      progressFill.style.width = pct + '%';
      progressText.textContent = 'Processing frame ' + frameCount + ' of ~' + estimatedFrames;
    });
    video.pause();
    URL.revokeObjectURL(video.src);

    // --- End card (if provided) ---
    if (ecFile) {
      progressText.textContent = 'Rendering end card...';
      var endVid = document.createElement('video');
      endVid.src = URL.createObjectURL(ecFile);
      endVid.muted = true;
      endVid.playsInline = true;
      await waitForVideoReady(endVid);

      await playVideoAndCapture(endVid, 1, function(vid) {
        renderFullScreen(vid);
      });
      endVid.pause();
      URL.revokeObjectURL(endVid.src);
    }

    // Wait for MediaRecorder to finalize
    await new Promise(function(resolve) {
      if (mediaRecorder.state === 'inactive') { resolve(); return; }
      mediaRecorder.onstop = resolve;
      if (mediaRecorder.state === 'recording') mediaRecorder.stop();
    });

    var mimeType = mediaRecorder.mimeType || 'video/webm';
    return new Blob(chunks, { type: mimeType });
  }

})();
</script>

</body>
</html>
